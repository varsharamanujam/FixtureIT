<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>FixtureIt — Badminton Fixture Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg:#0b1020; --bg2:#0e1528; --panel:#0f172a; --card:#111a2e;
    --fg:#e5eaf3; --muted:#9fb0c9; --border:#1f2a44;
    --accent:#22c55e; --accent-2:#16a34a; --danger:#ef4444;
    --ring:#60a5fa;
    --r:12px; --r-sm:10px;
    --s-1:6px; --s0:10px; --s1:12px; --s2:16px; --s3:20px; --s4:28px;
    --shadow:0 8px 24px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.04);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  html, body { overflow-x: hidden; }
  body{
    margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
    color:var(--fg);
    background: linear-gradient(180deg,#070b16 0%,#0b1020 50%,#0e1528 100%);
  }
  .container{max-width:1200px;margin:0 auto;padding:var(--s3) var(--s2);}
  .header{display:flex;align-items:center;justify-content:space-between;gap:var(--s2);margin-bottom:var(--s2);}
  .brand{display:flex;align-items:center;gap:var(--s1)}
  .logo{width:34px;height:34px;border-radius:10px;background: radial-gradient(100% 100% at 30% 20%, #34d399 0%, #22c55e 40%, #16a34a 100%);box-shadow: 0 6px 18px rgba(34,197,94,.35)}
  .title-wrap{display:flex;flex-direction:column;gap:2px}
  .title{font-weight:800;letter-spacing:.2px}
  .subtitle{color:var(--muted);font-size:12px}

  .btn{background:#121a2f;color:var(--fg);border:1px solid var(--border);padding:10px 14px;border-radius:12px;cursor:pointer;transition:.15s ease;display:inline-flex;align-items:center;gap:8px}
  .btn:hover{transform:translateY(-1px);border-color:#2a385e}
  .btn:focus-visible{outline:2px solid var(--ring);outline-offset:2px}
  .btn-primary{background:linear-gradient(180deg,var(--accent),var(--accent-2));border-color:var(--accent-2);color:#05140c;font-weight:800}
  .btn-ghost{background:transparent}
  .btn-block{width:100%;justify-content:center}

  .grid{display:grid;gap:var(--s2);grid-template-columns: 360px 1fr;}
  @media (max-width: 980px){ .grid{grid-template-columns: 1fr;} }

  .card{background: rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);border-radius:var(--r);padding:var(--s2);box-shadow: var(--shadow);position:relative;}
  .left .card{position:sticky; top:16px}

  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input,select,textarea{width:100%; background:#0b1220; color:var(--fg); border:1px solid var(--border); border-radius:10px; padding:10px 12px; outline:none;}
  input:focus-visible,select:focus-visible,textarea:focus-visible{border-color:#345397; box-shadow:0 0 0 3px rgba(96,165,250,.2)}
  textarea{min-height:150px;resize:vertical}
  .hint{color:var(--muted);font-size:12px;margin-top:6px}
  .row{display:flex;gap:var(--s1);align-items:center;flex-wrap:wrap}
  .divider{height:1px;background:rgba(255,255,255,.08);margin:var(--s2) 0}
  .section{display:flex;flex-direction:column;gap:var(--s1)}
  .section-title{font-size:12px;color:#b8c4db;text-transform:uppercase;letter-spacing:.12em}
  .control-2col{display:grid;grid-template-columns:1fr 1fr;gap:var(--s1)}
  @media (max-width:600px){ .control-2col{grid-template-columns:1fr} }

  .tags{display:flex;gap:8px;flex-wrap:wrap}
  .tag{font-size:12px;color:#a5b4fc;background:rgba(99,102,241,.12);border:1px solid rgba(99,102,241,.25);padding:4px 8px;border-radius:999px}

  .pill{font-size:12px;background:rgba(148,163,184,.15);color:#cbd5e1;border:1px solid rgba(148,163,184,.25);padding:4px 8px;border-radius:999px}

  /* Table view */
  table{width:100%;border-collapse:separate;border-spacing:0;margin-top:var(--s1)}
  thead th{text-align:left;font-weight:700;color:#c9d5eb;background:rgba(255,255,255,.04);position:sticky;top:0;padding:10px;border-bottom:1px solid rgba(255,255,255,.08);backdrop-filter:saturate(120%) blur(4px); z-index:2;}
  tbody td{padding:10px;border-bottom:1px solid rgba(255,255,255,.06);font-size:14px}
  tbody tr:nth-child(even){background:rgba(255,255,255,.02)}
  tbody tr:hover{background:rgba(96,165,250,.06)}

  /* View tabs */
  .tabs{display:flex;gap:6px;align-items:center}
  .tab{background:transparent;border:1px solid rgba(255,255,255,.16);color:#cdd7ec;padding:6px 10px;border-radius:999px;cursor:pointer;font-size:12px}
  .tab.active{background:rgba(255,255,255,.12);border-color:rgba(255,255,255,.28);color:#fff}
  .hidden{display:none !important}

  /* Flowchart */
  .flow-wrap {
    position: relative;
    width: 100%;
    max-width: 100%;
    min-width: 0;
    overflow: auto;          /* internal scroll only */
    padding: 6px;
    contain: layout paint;
  }
  .flow{display:grid; grid-auto-flow:column; grid-auto-columns: minmax(220px, 280px); gap:16px; align-items:start}
  .flow-col{display:flex; flex-direction:column; gap:12px}
  .flow-col .col-title{font-size:12px;color:#c9d5eb;letter-spacing:.08em;text-transform:uppercase}
  .match-card{background:#0e1528;border:1px solid #22304d;border-radius:12px;padding:10px;min-height:54px;box-shadow:0 6px 16px rgba(0,0,0,.22)}
  .match-title{font-weight:700}
  .match-sub{font-size:12px;color:#9fb0c9;margin-top:4px}
  .bye{opacity:.6}
  .connector{position:absolute; inset:0; pointer-events:none}

  /* Flowcard meta */
  .match-meta{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;font-size:11px;color:#9fb0c9}
  .chip{background:rgba(99,102,241,.15);color:#a5b4fc;border:1px solid rgba(99,102,241,.3);padding:2px 6px;border-radius:999px;font-weight:600}
  .footer{margin: var(--s3) 0;color:var(--muted);font-size:12px;text-align:center}
  .error{color:var(--danger);font-size:13px;margin-top:8px}

  .actions{display:flex;gap:var(--s1);flex-wrap:wrap}
  .actions .btn-primary{padding:12px 16px}

  /* Print */
@media print{
    @page { size: landscape; margin: 10mm; }
    body{ background:#fff; color:#000 }
    .left, .header, .footer, .btn, .hint, .tabs{ display:none !important }
    .card{ border:none; box-shadow:none; padding:0 }
    .container{ max-width:none; padding:0 }
    /* Table: repeat header; allow natural page breaks without dropping rows */
    table{ width:100%; font-size:12px; page-break-inside:auto; break-inside:auto; -webkit-print-color-adjust:exact; print-color-adjust: exact; }
    thead{ display: table-header-group; }
    tfoot{ display: table-footer-group; }
    tbody{ display: table-row-group !important; break-inside:auto; }
    tr{ break-inside: avoid; }
    thead th{ top:auto !important; }
    /* Ensure no scroll containers clip content */
    .grid{ display:block !important; grid-template-columns:1fr !important; }
    .right, .card, #view-table, table, tbody{ overflow: visible !important; height:auto !important; max-height:none !important; }
    thead th{ position:static; background:#eee; color:#000; border-bottom:1px solid #bbb }
    tbody td{ border-bottom:1px solid #ddd }

    /* Flow: wrap columns within page width, paginate vertically, hide connectors */
    #view-flow{ display:block !important; }
    .flow-wrap{ overflow: visible !important; height:auto !important; max-height:none !important; page-break-inside:auto !important; }
    .flow{ display:flex !important; flex-wrap:wrap; gap:12px; }
    .flow-col{ width:280px; page-break-inside: avoid !important; break-inside: avoid; }
    .match-card{ padding:8px; min-height:40px; page-break-inside: avoid; break-inside: avoid; }
    .match-title{ font-size:12px }
    .match-sub{ font-size:11px }
    .connector{ display:none !important }

    /* Keep round title with first card on the same page */
    .flow-col .col-title{ page-break-after: avoid; page-break-inside: avoid !important; break-after: avoid-page; }
  }

  /* Connector styling */
  .connector .flow-line{
    stroke: rgba(148,163,184,0.65);
    stroke-width: 2px;
    fill: none;
    vector-effect: non-scaling-stroke;
    shape-rendering: geometricPrecision;
    stroke-linecap: round;
    stroke-linejoin: round;
  }

  /* Ensure the right column can shrink and doesn’t force page overflow */
  .right { min-width: 0; }
  .right .card { min-width: 0; }

  /* Flow view should not expand the layout; it scrolls internally */
 #view-flow { min-width: 0; }
 .flow-wrap {
   position: relative;
   width: 100%;
   max-width: 100%;
   min-width: 0;
   overflow: auto;          /* internal scroll only */
   padding: 6px;
   contain: layout paint;
 }

  /* Let inner grid be as wide as needed; outer wrapper handles scroll */
  .flow { width: max-content; }

  /* Connectors already absolute; just reaffirm */
  .connector { position: absolute; inset: 0; pointer-events: none; }

  /* Flowchart round coloring */
  .flow-col:nth-child(odd) .match-card{ background: rgba(59,130,246,.12); border-color: rgba(59,130,246,.35); }
  .flow-col:nth-child(even) .match-card{ background: rgba(34,197,94,.12); border-color: rgba(34,197,94,.35); }
  .match-card.placeholder{ background: rgba(148,163,184,.12); border-color: rgba(148,163,184,.35); }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div class="title-wrap">
      <div class="title">FixtureIt — Badminton Fixture Generator</div>
        <div class="subtitle">Clean, fair schedules with multi‑court and rest constraints</div>
      </div>
    </div>
    <div class="row">
      <button id="btn-load" class="btn btn-ghost">Load</button>
      <button id="btn-save" class="btn">Save</button>
    </div>
  </div>

  <div class="grid">
    <div class="left">
      <div class="card">
        <div class="section">
          <div class="section-title">Tournament</div>
          <div>
            <label for="algorithm">Choose an algorithm</label>
        <select id="algorithm">
          <option value="roundrobin">Round-robin</option>
          <option value="knockout">Knockout (single-elimination)</option>
        </select>
          </div>
          <div id="seeded-wrap" class="row hidden" style="margin-top:-4px;">
            <label style="display:flex;gap:8px;align-items:center;margin:0;">
              <input id="seeded" type="checkbox" />
              Seeded knockout (teams listed as seeds)
            </label>
          </div>
        </div>

        <div class="divider"></div>

        <div class="section">
          <div class="section-title">Participants</div>
          <div>
        <label for="teams">Teams / Players (one per line)</label>
        <textarea id="teams" placeholder="Team A
Team B
Team C
Team D"></textarea>
            <div class="row" style="justify-content:space-between;">
              <div class="hint" id="team-hint">Odd count in round‑robin auto-adds a bye. Knockout pads to power of two.</div>
              <div class="pill" id="team-count">0 teams</div>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <div class="section">
          <div class="section-title">Constraints</div>
          <div class="control-2col">
            <div>
            <label for="courts">Courts</label>
            <input id="courts" type="number" min="1" value="2" />
          </div>
            <div>
            <label for="duration">Match duration (minutes)</label>
            <input id="duration" type="number" min="5" step="5" value="30" />
          </div>
        </div>
          <div class="control-2col">
            <div>
            <label for="rest">Min rest between a team's matches (minutes)</label>
            <input id="rest" type="number" min="0" step="5" value="30" />
          </div>
            <div>
            <label for="start">Start time</label>
            <input id="start" type="datetime-local" />
          </div>
        </div>
        </div>

        <div class="divider"></div>

        <div class="actions">
          <button id="btn-generate" class="btn btn-primary btn-block">Generate Schedule</button>
        </div>

        <div id="errors" class="error" role="alert" aria-live="polite"></div>
      </div>
    </div>

    <div class="right">
      <div class="card">
        <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:6px;">
          <div class="pill" id="summary">No schedule generated yet.</div>
          <div class="row">
            <div class="tabs" role="tablist" aria-label="View toggle between table and flowchart">
              <span class="toggle-label" style="color:#9fb0c9;font-size:12px;margin-right:6px;">View:</span>
              <button id="tab-table" class="tab active" role="tab" aria-selected="true" aria-controls="view-table" title="Table – detailed list of all scheduled matches">Table</button>
              <button id="tab-flow" class="tab" role="tab" aria-selected="false" aria-controls="view-flow" title="Flowchart – rounds/bracket layout">Flowchart</button>
            </div>
            <button id="btn-flow-download" class="btn" style="margin-left:8px;" title="Download flowchart as JPEG image">Download Flowchart</button>
            <div style="position:relative;">
              <button id="btn-table-download" class="btn" title="Download schedule table">Download Table</button>
              <div id="table-menu" class="hidden" style="position:absolute; right:0; top:36px; background:#0b1220; border:1px solid #1f2937; border-radius:8px; padding:6px; z-index:5; min-width:140px;">
                <button id="btn-table-pdf" class="btn" style="width:100%; margin:2px 0;">PDF</button>
                <button id="btn-table-csv" class="btn" style="width:100%; margin:2px 0;">CSV</button>
              </div>
            </div>
          </div>
        </div>
        <div class="row" style="margin-bottom:6px;">
            <div class="pill" id="algo-pill">—</div>
            <div class="pill" id="meta-pill">—</div>
          </div>
        <div class="tags" style="margin-bottom:8px;">
          <span class="tag">Round-robin</span>
          <span class="tag">Knockout</span>
          <span class="tag">Multi-court</span>
          <span class="tag">Rest constraints</span>
          <span class="tag">CSV export</span>
        </div>

        <!-- Table View -->
        <div id="view-table">
          <table aria-describedby="summary">
          <thead>
            <tr>
              <th>#</th>
              <th>Round</th>
              <th>Match</th>
              <th>Team A</th>
              <th>Team B</th>
              <th>Court</th>
              <th>Start</th>
              <th>End</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
        </table>
      </div>

        <!-- Flowchart View -->
        <div id="view-flow" class="hidden">
          <div class="flow-wrap" id="flow-wrap">
            <svg class="connector" id="flow-svg"></svg>
            <div class="flow" id="flow"></div>
          </div>
        </div>
      </div>
      <div class="footer">Saved inputs persist in this browser (localStorage).</div>
    </div>
  </div>
</div>

<script>
  // Light-weight loader for jsPDF + autotable from CDN when needed
  function ensurePdfLibsLoaded() {
    return new Promise((resolve, reject) => {
      const has = !!(window.jspdf && window.jspdf.jsPDF && (window.jspdf.jsPDF.prototype?.autoTable || window.jspdfAutoTable || window.autoTable));
      if (has) return resolve();
      const s1 = document.createElement('script');
      s1.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
      s1.onload = () => {
        const s2 = document.createElement('script');
        s2.src = 'https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.3/dist/jspdf.plugin.autotable.min.js';
        s2.onload = resolve; s2.onerror = reject; document.head.appendChild(s2);
      };
      s1.onerror = reject; document.head.appendChild(s1);
    });
  }

  // Loader for svg2pdf (vector export of flowchart)
  function ensureSvg2PdfLoaded(){
    return new Promise((resolve, reject)=>{
      const has = !!(window.svg2pdf || (window.svg2pdf && window.svg2pdf.default));
      if (has) return resolve();
      const s=document.createElement('script');
      // Try plain UMD first; fallback to non-UMD build naming
      const candidates = [
        'https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.4/dist/svg2pdf.umd.min.js',
        'https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.4/dist/svg2pdf.min.js'
      ];
      let idx = 0;
      const tryNext = () => {
        if (idx >= candidates.length) { reject(new Error('svg2pdf failed to load')); return; }
        s.src = candidates[idx++];
        s.onload = () => resolve();
        s.onerror = tryNext;
        document.head.appendChild(s);
      };
      tryNext();
    });
  }

  // Build a single SVG that represents the current flow view (cards + connectors)
  function buildFlowSvg(){
    const contentW = Math.max(el.flowWrap.scrollWidth, el.flowWrap.clientWidth);
    const contentH = Math.max(el.flowWrap.scrollHeight, el.flowWrap.clientHeight);
    const contentRect = el.flow.getBoundingClientRect();
    const scrollX = el.flowWrap.scrollLeft, scrollY = el.flowWrap.scrollTop;
    const ns = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(ns,'svg');
    svg.setAttribute('xmlns','http://www.w3.org/2000/svg');
    svg.setAttribute('width', String(contentW));
    svg.setAttribute('height', String(contentH));
    svg.setAttribute('viewBox', `0 0 ${contentW} ${contentH}`);

    // No connectors in exported SVG by design (clean bracket cards only)

    // Draw cards as rounded rects + text
    const cards = el.flow.querySelectorAll('.match-card');
    cards.forEach(card=>{
      const r = card.getBoundingClientRect();
      const x = (r.left - contentRect.left) + scrollX;
      const y = (r.top - contentRect.top) + scrollY;
      const w = r.width; const h = r.height;
      const rect = document.createElementNS(ns,'rect');
      rect.setAttribute('x', x); rect.setAttribute('y', y); rect.setAttribute('width', w); rect.setAttribute('height', h);
      rect.setAttribute('rx','10'); rect.setAttribute('ry','10');
      rect.setAttribute('fill', getComputedStyle(card).backgroundColor || '#eef2ff');
      rect.setAttribute('stroke', '#93c5fd'); rect.setAttribute('stroke-width','1');
      svg.appendChild(rect);

      const meta = card.querySelector('.match-meta .chip');
      const title = card.querySelector('.match-title');
      const sub = card.querySelector('.match-sub');

      const addText = (text, tx, ty, size=11, weight='normal')=>{
        const t = document.createElementNS(ns,'text');
        t.setAttribute('x', tx);
        t.setAttribute('y', ty);
        t.setAttribute('font-size', String(size));
        t.setAttribute('font-family', 'Helvetica, Arial, sans-serif');
        if (weight==='bold') t.setAttribute('font-weight','bold');
        t.setAttribute('fill', '#0f172a');
        t.textContent = text || '';
        svg.appendChild(t);
      };

      // simple text wrapping utility for SVG
      const wrap = (text, maxWidth, lineHeight, size, weight) => {
        const words = (text||'').split(/\s+/);
        let line = '';
        const lines = [];
        const measure = (s)=> s.length * (size*0.6); // rough width estimate
        for (let i=0;i<words.length;i++){
          const trial = line ? line + ' ' + words[i] : words[i];
          if (measure(trial) > maxWidth && line){ lines.push(line); line = words[i]; }
          else line = trial;
        }
        if (line) lines.push(line);
        return lines;
      };

      const PAD = 10;
      let cursorY = y + PAD + 10;
      const maxW = w - PAD*2;
      if (meta) {
        const lines = wrap(meta.textContent.trim(), maxW, 12, 10);
        lines.forEach((ln)=>{ addText(ln, x+PAD, cursorY, 10); cursorY += 12; });
      }
      if (title){
        const lines = wrap(title.textContent.trim(), maxW, 14, 12);
        lines.forEach((ln)=>{ addText(ln, x+PAD, cursorY, 12, 'bold'); cursorY += 16; });
      }
      if (sub){
        const lines = wrap(sub.textContent.trim(), maxW, 12, 10);
        lines.forEach((ln)=>{ addText(ln, x+PAD, cursorY, 10); cursorY += 12; });
      }
    });

    return { svg, width: contentW, height: contentH };
  }
  // Utilities
  const uniqId = (()=>{ let i=1; return () => i++; })();
  const fmtTime = (d) => new Date(d).toLocaleString();
  const addMinutes = (d, mins) => new Date(d.getTime() + mins*60000);

  const $ = (id) => document.getElementById(id);
  const el = {
    algorithm: $('algorithm'),
    seededWrap: $('seeded-wrap'),
    seeded: $('seeded'),
    teams: $('teams'),
    teamCount: $('team-count'),
    courts: $('courts'),
    duration: $('duration'),
    rest: $('rest'),
    start: $('start'),
    btnGen: $('btn-generate'),
    btnExport: $('btn-export'),
    btnPrint: $('btn-print'),
    btnSave: $('btn-save'),
    btnLoad: $('btn-load'),
    errors: $('errors'),
    tbody: $('tbody'),
    summary: $('summary'),
    algoPill: $('algo-pill'),
    metaPill: $('meta-pill'),
    tabTable: $('tab-table'),
    tabFlow: $('tab-flow'),
    viewTable: $('view-table'),
    viewFlow: $('view-flow'),
    flow: $('flow'),
    flowWrap: $('flow-wrap'),
    flowSvg: $('flow-svg'),
  };

  function parseTeams(input){ return input.split(/\r?\n/).map(s=>s.trim()).filter(Boolean); }
  function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

  // Round-robin via Circle Method
  function roundRobinRounds(teams){
    const list = teams.slice();
    const hasBye = list.length % 2 === 1;
    if (hasBye) list.push('BYE');
    const n = list.length;
    const rounds = [];
    for (let r = 0; r < n - 1; r++) {
      const pairs = [];
      for (let i = 0; i < n / 2; i++) {
        const t1 = list[i], t2 = list[n - 1 - i];
        if (t1 !== 'BYE' && t2 !== 'BYE') pairs.push({ a:t1, b:t2, play:true, label:`R${r+1}-M${i+1}` });
        else pairs.push({ a:t1, b:t2, play:false, label:`R${r+1}-M${i+1}` });
      }
      rounds.push(pairs);
      const fixed = list[0], rest = list.slice(1); rest.unshift(rest.pop()); list.splice(0, list.length, fixed, ...rest);
    }
    return rounds;
  }

  // Knockout bracket generator
  function nextPowerOfTwo(x){ let p=1; while(p<x) p<<=1; return p; }
  function knockoutRounds(teams, seeded=false){
    const n=teams.length, size=nextPowerOfTwo(n);
    let entrants = seeded ? teams.slice() : shuffle(teams.slice());
    while (entrants.length < size) entrants.push('BYE');
    const r1=[];
    for (let i=0;i<size;i+=2){
      const a=entrants[i], b=entrants[i+1];
      if (a==='BYE' && b==='BYE') continue;
      r1.push({ a, b, play: !(a==='BYE' || b==='BYE'), label:`R1-M${(i/2)+1}` });
    }
    const rounds=[]; rounds.push(r1);
    let prev=r1, r=2;
    while(prev.length>1){
      const cur=[];
      for(let i=0;i<prev.length;i+=2){
        const L=prev[i], R=prev[i+1]; if(!R) continue;
        const aL = L.play ? `Winner of ${L.label}` : (L.a==='BYE'?L.b:L.a);
        const bL = R.play ? `Winner of ${R.label}` : (R.a==='BYE'?R.b:R.a);
        cur.push({ a:aL, b:bL, play:true, label:`R${r}-M${(i/2)+1}` });
      }
      rounds.push(cur); prev=cur; r++;
    }
    return rounds;
  }

  // Scheduler with rest + multi-court
  function scheduleMatches(rounds, config, type){
    const { courts, duration, rest, start } = config;
    const startTime = new Date(start);
    const courtNext = Array.from({length:courts}, ()=> new Date(startTime));
    const teamLast = new Map(); const out=[];

    const canPlayAt = (team, t) => {
      const last = teamLast.get(team); if(!last) return true;
      return (t.getTime()-last.getTime())/60000 >= rest;
    };
    const assign = (earliest) => {
      let bestCourt=0, bestTime=null;
      for (let c=0;c<courts;c++){
        const t0 = new Date(Math.max(courtNext[c].getTime(), earliest.getTime()));
        if (bestTime===null || t0<bestTime){ bestTime=t0; bestCourt=c; }
      }
      return { court:bestCourt, time:bestTime };
    };

    if (type==='roundrobin'){
      const queue=[];
      rounds.forEach((pairs,i)=> pairs.forEach((p,j)=> { if(p.a!=='BYE' && p.b!=='BYE') queue.push({round:i+1,matchInRound:j+1,a:p.a,b:p.b}); }));
      let guard=0;
      while(queue.length && guard++<100000){
        let placed=false;
        const earliestTime = new Date(Math.min(...courtNext.map(d=>d.getTime())));
        for (let idx=0; idx<queue.length; idx++){
          const m=queue[idx];
          if (canPlayAt(m.a,earliestTime) && canPlayAt(m.b,earliestTime)){
            const {court,time}=assign(earliestTime);
            const end=addMinutes(time,duration);
            out.push({ id:uniqId(), round:m.round, matchInRound:m.matchInRound, a:m.a, b:m.b, court:court+1, start:new Date(time), end });
            teamLast.set(m.a,end); teamLast.set(m.b,end); courtNext[court]=new Date(end);
            queue.splice(idx,1); placed=true; break;
          }
        }
        if(!placed){
          const k=courtNext.reduce((mi,d,i)=> d<courtNext[mi]?i:mi,0);
          courtNext[k]=addMinutes(courtNext[k],5);
        }
      }
      if(queue.length) throw new Error('Could not schedule all matches with current constraints.');
      return out.sort((a,b)=> a.start-b.start || a.court-b.court);
    }

    if (type==='knockout'){
      let currentStart = new Date(startTime);
      for (let r=0;r<rounds.length;r++){
        const pairs=rounds[r];
        for (let c=0;c<courts;c++) courtNext[c]=new Date(Math.max(courtNext[c].getTime(), currentStart.getTime()));
        const queue=[];
        pairs.forEach((p,j)=>{ if(!(p.play===false || p.a==='BYE' || p.b==='BYE')) queue.push({round:r+1,matchInRound:j+1,a:p.a,b:p.b}); });
        let guard=0;
        while(queue.length && guard++<100000){
          const earliestTime = new Date(Math.min(...courtNext.map(d=>d.getTime())));
          let placed=false;
          for (let idx=0; idx<queue.length; idx++){
            const m=queue[idx];
            const aCan = !m.a.startsWith('Winner of') ? canPlayAt(m.a,earliestTime) : true;
            const bCan = !m.b.startsWith('Winner of') ? canPlayAt(m.b,earliestTime) : true;
            if (aCan && bCan){
              const {court,time}=assign(earliestTime);
              const end=addMinutes(time,duration);
              out.push({ id:uniqId(), round:m.round, matchInRound:m.matchInRound, a:m.a, b:m.b, court:court+1, start:new Date(time), end });
              if(!m.a.startsWith('Winner of')) teamLast.set(m.a,end);
              if(!m.b.startsWith('Winner of')) teamLast.set(m.b,end);
              courtNext[court]=new Date(end);
              queue.splice(idx,1); placed=true; break;
            }
          }
          if(!placed){
            const k=courtNext.reduce((mi,d,i)=> d<courtNext[mi]?i:mi,0);
            courtNext[k]=addMinutes(courtNext[k],5);
          }
        }
        const roundFinish = new Date(Math.max(...courtNext.map(d=>d.getTime())));
        currentStart = addMinutes(roundFinish, rest);
      }
      return out.sort((a,b)=> a.start-b.start || a.court-b.court);
    }

    throw new Error('Unknown type');
  }

  function toCSV(rows){
    const header=['#','Round','Match','Team A','Team B','Court','Start','End'];
    const lines=[header.join(',')];
    rows.forEach((r,i)=>{
      lines.push([i+1,r.round,r.matchInRound,`"${r.a}"`,`"${r.b}"`,r.court,`"${fmtTime(r.start)}"`,`"${fmtTime(r.end)}"`].join(','));
    });
    return lines.join('\n');
  }

  function readConfig(){
    const teams = parseTeams(el.teams.value);
    const courts = Math.max(1, parseInt(el.courts.value||'1',10));
    const duration = Math.max(5, parseInt(el.duration.value||'30',10));
    const rest = Math.max(0, parseInt(el.rest.value||'30',10));
    const startVal = el.start.value;
    return { teams, courts, duration, rest, start: startVal ? new Date(startVal) : new Date(), seeded: el.seeded.checked };
  }

  function renderTable(rows){
    el.tbody.innerHTML='';
    rows.forEach((r,i)=>{
      const tr=document.createElement('tr');
      [i+1,r.round,r.matchInRound,r.a,r.b,r.court,fmtTime(r.start),fmtTime(r.end)].forEach(v=>{
        const td=document.createElement('td'); td.textContent=String(v); tr.appendChild(td);
      });
      el.tbody.appendChild(tr);
    });
  }

  function setSummary(rows,type,cfg,teamsCount){
    if(!rows.length){ el.summary.textContent='No schedule generated yet.'; el.algoPill.textContent='—'; el.metaPill.textContent='—'; return; }
    const first=rows[0]?.start, last=rows[rows.length-1]?.end;
    const totalMins=Math.round((last-first)/60000);
    el.summary.textContent=`${rows.length} matches • ~${totalMins} mins • ${cfg.courts} court(s)`;
    el.algoPill.textContent = type==='roundrobin' ? 'Round-robin' : 'Knockout';
    el.metaPill.textContent = `${teamsCount} teams • ${cfg.duration}m/match • ${cfg.rest}m rest`;
  }

  function groupRowsByRound(rows){
    const map=new Map();
    rows.forEach(r=>{
      if(!map.has(r.round)) map.set(r.round, []);
      map.get(r.round).push(r);
    });
    [...map.values()].forEach(list=>list.sort((a,b)=>a.start-b.start));
    return map;
  }

  // Flowchart rendering
  function renderFlowchart(structureRounds, rows, type){
    el.flow.innerHTML='';
    el.flowSvg.innerHTML='';

    const rowsByRound = groupRowsByRound(rows||[]);
    const cardRefs = [];

    // Build columns and cards
    structureRounds.forEach((round, idx)=>{
      const col=document.createElement('div'); col.className='flow-col';
      const title=document.createElement('div'); title.className='col-title';
      title.textContent = type==='roundrobin'
        ? `Round ${idx+1}`
        : (idx===structureRounds.length-1?'Final': idx===structureRounds.length-2?'Semifinals': idx===0?'Round of '+ (round.length*2): `Round ${idx+1}`);
      col.appendChild(title);

      const refs=[];
      round.forEach((m, j)=>{
        if (type==='roundrobin' && (m.a==='BYE' || m.b==='BYE')) return;
        const card=document.createElement('div'); card.className='match-card'; if(m.play===false) card.classList.add('bye');
        // mark placeholder (unknown entrants)
        if (type==='knockout' && ((m.a && String(m.a).startsWith('Winner of')) || (m.b && String(m.b).startsWith('Winner of')))) {
          card.classList.add('placeholder');
        }

        // meta row with round/match info
        const meta=document.createElement('div'); meta.className='match-meta';
        const label = m.label || `R${idx+1}-M${j+1}`;
        meta.innerHTML = `<span class="chip">${label}</span><span>Round ${idx+1} • Match ${j+1}</span>`;
        card.appendChild(meta);

        const head=document.createElement('div'); head.className='match-title';
        head.textContent = (m.a||'') + ' vs ' + (m.b||'');
        const sub=document.createElement('div'); sub.className='match-sub';
        const scheduled = (rowsByRound.get(idx+1)||[]).find(rw=> rw.a===m.a && rw.b===m.b);
        sub.textContent = scheduled ? `Court ${scheduled.court} • ${fmtTime(scheduled.start)}` : (type==='knockout' && idx>0 ? 'TBD' : (m.play===false?'BYE':''));
        card.appendChild(head); card.appendChild(sub);
        col.appendChild(card); refs.push(card);
      });

      el.flow.appendChild(col);
      cardRefs.push(refs);
    });

    // Size SVG to the full scroll area of the wrapper
    const contentW = Math.max(el.flowWrap.scrollWidth, el.flowWrap.clientWidth);
    const contentH = Math.max(el.flowWrap.scrollHeight, el.flowWrap.clientHeight);
    el.flowSvg.setAttribute('width', contentW);
    el.flowSvg.setAttribute('height', contentH);
    el.flowSvg.setAttribute('viewBox', `0 0 ${contentW} ${contentH}`);
    el.flowSvg.style.width = contentW + 'px';
    el.flowSvg.style.height = contentH + 'px';
    // keep overlay pinned to the wrap (CSS .connector { inset: 0 })
    el.flowSvg.style.left = el.flow.offsetLeft + 'px';
    el.flowSvg.style.top = el.flow.offsetTop + 'px';

    if (type!=='knockout') return; // connectors only for knockout

    const ns = 'http://www.w3.org/2000/svg';
    const wrapRect = el.flowWrap.getBoundingClientRect();
    const scrollX = el.flowWrap.scrollLeft;
    const scrollY = el.flowWrap.scrollTop;

    // Coordinates relative to wrap content origin
    const pointRight = (node) => {
      const r = node.getBoundingClientRect();
      const x = (r.right - wrapRect.left) + scrollX;
      const y = (r.top - wrapRect.top) + scrollY + r.height/2;
      return {x, y};
    };
    const pointLeft = (node) => {
      const r = node.getBoundingClientRect();
      const x = (r.left - wrapRect.left) + scrollX;
      const y = (r.top - wrapRect.top) + scrollY + r.height/2;
      return {x, y};
    };
    const pathFor = (x1,y1,x2,y2) => {
      if (PRINTING) {
        const xm = (x1 + x2) / 2; // elbow in the middle for clarity
        return `M ${x1} ${y1} L ${xm} ${y1} L ${xm} ${y2} L ${x2} ${y2}`;
      } else {
        const dx = Math.max(40, Math.abs(x2-x1)/2);
        return `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`;
      }
    };

    for (let r=0; r<cardRefs.length-1; r++){
      const srcList = cardRefs[r];
      const dstList = cardRefs[r+1];
      for (let i=0; i<srcList.length; i+=2){
        const a = srcList[i];
        const b = srcList[i+1];
        const dest = dstList[Math.floor(i/2)];
        if (!a || !dest) continue;

        const A = pointRight(a);
        const D = pointLeft(dest);
        const p1 = document.createElementNS(ns,'path');
        p1.setAttribute('class','flow-line');
        p1.setAttribute('d', pathFor(A.x, A.y, D.x, D.y));
        p1.setAttribute('fill','none');
        p1.setAttribute('stroke','rgba(148,163,184,0.55)');
        p1.setAttribute('stroke-width','2');
        p1.setAttribute('stroke-linecap','round');
        p1.setAttribute('stroke-linejoin','round');
        p1.setAttribute('vector-effect','non-scaling-stroke');
        el.flowSvg.appendChild(p1);

        if (b){
          const B = pointRight(b);
          const p2 = document.createElementNS(ns,'path');
          p2.setAttribute('class','flow-line');
          p2.setAttribute('d', pathFor(B.x, B.y, D.x, D.y));
          p2.setAttribute('fill','none');
          p2.setAttribute('stroke','rgba(148,163,184,0.55)');
          p2.setAttribute('stroke-width','2');
          p2.setAttribute('stroke-linecap','round');
          p2.setAttribute('stroke-linejoin','round');
          p2.setAttribute('vector-effect','non-scaling-stroke');
          el.flowSvg.appendChild(p2);
        }
      }
    }
  }

  function saveState(){
    const data={
      algorithm: el.algorithm.value,
      teams: el.teams.value,
      courts: el.courts.value,
      duration: el.duration.value,
      rest: el.rest.value,
      start: el.start.value,
      seeded: el.seeded.checked,
    };
    localStorage.setItem('fixtureit_state', JSON.stringify(data));
  }
  function loadState(){
    const raw=localStorage.getItem('fixtureit_state'); if(!raw) return;
    try{
      const d=JSON.parse(raw);
      el.algorithm.value=d.algorithm||'roundrobin';
      el.teams.value=d.teams||'';
      el.courts.value=d.courts||'2';
      el.duration.value=d.duration||'30';
      el.rest.value=d.rest||'30';
      el.start.value=d.start||'';
      el.seeded.checked=!!d.seeded;
    }catch{}
  }

  // Live UX helpers
  function updateTeamCount(){
    const n=parseTeams(el.teams.value).length;
    el.teamCount.textContent = `${n} ${n===1?'team':'teams'}`;
  }
  function toggleSeeded(){
    const isKO = el.algorithm.value==='knockout';
    el.seededWrap.classList.toggle('hidden', !isKO);
  }
  function setView(view){
    const isTable = view==='table';
    el.viewTable.classList.toggle('hidden', !isTable);
    el.viewFlow.classList.toggle('hidden', isTable);
    el.tabTable.classList.toggle('active', isTable);
    el.tabFlow.classList.toggle('active', !isTable);
    el.tabTable.setAttribute('aria-selected', String(isTable));
    el.tabFlow.setAttribute('aria-selected', String(!isTable));
  }

  // Events
  let lastRows=[], lastType='roundrobin', lastCfg=null, lastTeamsCount=0, lastStructure=[];
  let PRINTING = false;
  el.btnGen.addEventListener('click', ()=>{
    el.errors.textContent='';
    try{
      const cfg=readConfig();
      if (cfg.teams.length<2) throw new Error('Enter at least two teams.');
      const type=el.algorithm.value;
      const teamsCount=cfg.teams.length;

      const structure = type==='roundrobin' ? roundRobinRounds(cfg.teams)
                      : type==='knockout' ? knockoutRounds(cfg.teams,cfg.seeded)
                      : (()=>{throw new Error('Unknown format.')})();

      const rows=scheduleMatches(structure,{courts:cfg.courts,duration:cfg.duration,rest:cfg.rest,start:cfg.start},type);

      lastRows=rows; lastType=type; lastCfg=cfg; lastTeamsCount=teamsCount; lastStructure=structure;

      renderTable(rows);
      renderFlowchart(structure, rows, type);
      setSummary(rows,type,cfg,teamsCount);
      saveState();
    } catch (e){
      el.errors.textContent = e.message || String(e);
      lastRows=[]; renderTable([]); setSummary([], '', {}, 0);
      el.flow.innerHTML=''; el.flowSvg.innerHTML='';
    }
  });

  el.tabTable.addEventListener('click', ()=> setView('table'));
  el.tabFlow.addEventListener('click', ()=> {
    setView('flow');
    if (lastStructure.length) renderFlowchart(lastStructure, lastRows, lastType);
  });

  // Old CSV button replaced by menu
  document.getElementById('btn-table-csv').addEventListener('click', ()=>{
    if(!lastRows.length){ el.errors.textContent='Generate a schedule first.'; return; }
    el.errors.textContent='';
    const csv=toCSV(lastRows);
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='fixtureit_schedule.csv'; a.click(); URL.revokeObjectURL(url);
  });

  // Export PDF using jsPDF + autoTable (Table only)
  async function exportTablePDF(){
    if(!lastRows.length){ el.errors.textContent='Generate a schedule first.'; return; }
    el.errors.textContent='';
    try{
      await ensurePdfLibsLoaded();
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ orientation:'landscape', unit:'pt', format:'a4' });
      const title = (el.algoPill.textContent || 'Schedule') + ' — ' + (new Date()).toLocaleString();
      doc.setFontSize(14); doc.text('FixtureIt — Badminton Fixture Generator', 40, 36);
      doc.setFontSize(10); doc.text(title, 40, 52);
      const head = [['#','Round','Match','Team A','Team B','Court','Start','End']];
      const body = lastRows.map((r,i)=>[ i+1, r.round, r.matchInRound, r.a, r.b, r.court, new Date(r.start).toLocaleString(), new Date(r.end).toLocaleString() ]);
      const autoTable = (doc).autoTable ? (opts)=>doc.autoTable(opts) : (window.jspdfAutoTable || window.autoTable);
      if (!autoTable) throw new Error('autoTable plugin not available');
      autoTable({ head, body, startY: 64, styles:{ fontSize:9, cellPadding:4 }, headStyles:{ fillColor:[238,238,238], textColor:0 }, alternateRowStyles:{ fillColor:[248,248,248] }, theme:'grid', margin:{ left:36, right:36 }, didDrawPage:(data)=>{ const pg=doc.getNumberOfPages(); doc.setFontSize(9); doc.text(`Page ${pg}`, data.settings.margin.left, doc.internal.pageSize.getHeight()-12); } });
      doc.save('fixtureit_schedule.pdf');
    } catch (e){ el.errors.textContent = 'PDF export failed. ' + (e.message||e); }
  }

  // Export Flowchart PDF (vector) regardless of active tab
  async function exportFlowPDF(){
    if(!lastRows.length){ el.errors.textContent='Generate a schedule first.'; return; }
    el.errors.textContent='';
    // Export flowchart as vector PDF regardless of active tab by measuring flow DOM
    try{
      await ensurePdfLibsLoaded();
      const wasHidden = el.viewFlow.classList.contains('hidden');
      const prevInline = el.viewFlow.getAttribute('style') || '';
      if (wasHidden){
        el.viewFlow.classList.remove('hidden');
        el.viewFlow.style.position='absolute';
        el.viewFlow.style.left='-10000px';
        el.viewFlow.style.top='-10000px';
        el.viewFlow.style.visibility='hidden';
        renderFlowchart(lastStructure, lastRows, lastType);
      }

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ orientation:'landscape', unit:'pt', format:'a4' });
      const pageW = doc.internal.pageSize.getWidth();
      const pageH = doc.internal.pageSize.getHeight();

      // Measure content
      const contentRect = el.flow.getBoundingClientRect();
      const contentW = Math.max(el.flowWrap.scrollWidth, el.flowWrap.clientWidth);
      const contentH = Math.max(el.flowWrap.scrollHeight, el.flowWrap.clientHeight);
      const scale = Math.min(pageW / contentW, pageH / contentH);
      const offsetX = (pageW - contentW * scale) / 2;
      const offsetY = (pageH - contentH * scale) / 2;
      const scrollX = el.flowWrap.scrollLeft, scrollY = el.flowWrap.scrollTop;

      const toPt = (x) => x * scale;
      const px = (v) => v; // input in px

      // Parse css rgb/rgba and blend with white based on alpha to approximate UI translucency
      const parseColor = (str)=>{
        const m = String(str).match(/rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*([0-9\.]+))?\)/i);
        if (!m) return { r:238, g:238, b:238, a:1 };
        return { r: parseInt(m[1],10), g: parseInt(m[2],10), b: parseInt(m[3],10), a: m[4]!==undefined ? parseFloat(m[4]) : 1 };
      };
      const blendOnWhite = ({r,g,b,a})=>({
        r: Math.round(r*a + 255*(1-a)),
        g: Math.round(g*a + 255*(1-a)),
        b: Math.round(b*a + 255*(1-a))
      });

      // Draw cards
      const cols = Array.from(el.flow.querySelectorAll('.flow-col'));
      const colCards = cols.map(c=> Array.from(c.querySelectorAll('.match-card')));
      const measured = new Map();
      const PAD = 14;
      colCards.forEach(cards=>{
        cards.forEach(card=>{
          const r = card.getBoundingClientRect();
          const x = (r.left - contentRect.left) + scrollX;
          const y = (r.top - contentRect.top) + scrollY;
          const w = r.width; const h = r.height;
          const styles = getComputedStyle(card);
          const bgCol = blendOnWhite(parseColor(styles.backgroundColor));
          const brCol = parseColor(styles.borderColor);
          doc.setDrawColor(brCol.r, brCol.g, brCol.b);
          doc.setFillColor(bgCol.r, bgCol.g, bgCol.b);
          const rx = Math.max(6, 8 * scale);

          // Measure text to decide dynamic height
          const PADpt = toPt(px(PAD));
          const textWidthPt = toPt(px(w - PAD*2));
          const metaChip = card.querySelector('.match-meta .chip');
          const titleEl = card.querySelector('.match-title');
          const subEl = card.querySelector('.match-sub');
          const metaLines = metaChip ? doc.splitTextToSize(metaChip.textContent.trim(), textWidthPt).length : 0;
          const titleLines = titleEl ? doc.splitTextToSize(titleEl.textContent.trim(), textWidthPt).length : 0;
          const subLines = subEl ? doc.splitTextToSize(subEl.textContent.trim(), textWidthPt).length : 0;
          const metaLH = 12, titleLH = 14, subLH = 12; // in pt
          const contentHeightPt = PADpt + metaLines*metaLH + titleLines*titleLH + subLines*subLH + PADpt + 4;
          const domHPt = toPt(px(h));
          const rectHPt = Math.max(domHPt, contentHeightPt);
          measured.set(card, { x, y, w, rectHPt });

          doc.roundedRect(offsetX + toPt(px(x)), offsetY + toPt(px(y)), toPt(px(w)), rectHPt, rx, rx, 'FD');

          // Text
          let cy = offsetY + toPt(px(y)) + PADpt;
          const leftX = offsetX + toPt(px(x + PAD));
          const textWidth = textWidthPt;
          doc.setTextColor(17,24,39); // near-black for readability
          doc.setFont('helvetica','normal');
          doc.setFontSize(9);
          if (metaChip){
            let meta = metaChip.textContent.trim();
            const metaArr = doc.splitTextToSize(meta, textWidth);
            doc.text(metaArr, leftX, cy);
            cy += metaLH * metaArr.length;
          }
          if (titleEl){
            doc.setFont('helvetica','bold'); doc.setFontSize(11);
            const ttl = titleEl.textContent.trim();
            const lines = doc.splitTextToSize(ttl, textWidth);
            doc.text(lines, leftX, cy);
            cy += titleLH * lines.length;
          }
          doc.setFont('helvetica','normal'); doc.setFontSize(9);
          if (subEl){
            doc.setTextColor(71,85,105); // slate
            const sub = subEl.textContent.trim();
            const lines2 = doc.splitTextToSize(sub, textWidth);
            doc.text(lines2, leftX, cy);
            doc.setTextColor(17,24,39);
          }
        });
      });

      // Draw orthogonal connectors between columns (every 2 cards -> 1 next column card)
      // Style for connectors in PDF export
      doc.setDrawColor(148,163,184); doc.setLineWidth(1.2);
      for (let rIdx=0; rIdx<colCards.length-1; rIdx++){
        const src = colCards[rIdx]; const dst = colCards[rIdx+1];
        for (let i=0; i<src.length; i+=2){
          const a = src[i]; const b = src[i+1]; const d = dst[Math.floor(i/2)]; if (!a || !d) continue;

          const ar = a.getBoundingClientRect(); const dr = d.getBoundingClientRect();
          const aMeasure = measured.get(a); const dMeasure = measured.get(d);
          const ax = (ar.right - contentRect.left) + scrollX - 10; 
          const dx = (dr.left - contentRect.left) + scrollX + 10; 
          const ay = aMeasure ? ( (aMeasure.y) + (aMeasure.rectHPt/scale)/2 ) : ((ar.top - contentRect.top) + scrollY + ar.height/2);
          const dy = dMeasure ? ( (dMeasure.y) + (dMeasure.rectHPt/scale)/2 ) : ((dr.top - contentRect.top) + scrollY + dr.height/2);
          const draw = (x1,y1,x2,y2)=>{
            doc.line(offsetX + toPt(px(x1)), offsetY + toPt(px(y1)), offsetX + toPt(px(x2)), offsetY + toPt(px(y2))); };
          // straight connector
          draw(ax, ay, dx, dy);
          if (b){
            const br = b.getBoundingClientRect();
            const bx = (br.right - contentRect.left) + scrollX - 10; const by = (br.top - contentRect.top) + scrollY + br.height/2;
            draw(bx, by, dx, dy);
          }
        }
      }

      doc.save('fixtureit_flowchart.pdf');
      if (wasHidden){
        el.viewFlow.classList.add('hidden');
        el.viewFlow.setAttribute('style', prevInline);
      }
    }catch(e){ el.errors.textContent = 'Flowchart PDF export failed. ' + (e.message||e); }
  }
  document.getElementById('btn-table-pdf').addEventListener('click', exportTablePDF);
  // Toggle table menu
  const tableMenu = document.getElementById('table-menu');
  document.getElementById('btn-table-download').addEventListener('click', ()=>{
    tableMenu.classList.toggle('hidden');
  });
  document.addEventListener('click', (e)=>{
    const btn = document.getElementById('btn-table-download');
    if (!tableMenu.contains(e.target) && e.target !== btn) tableMenu.classList.add('hidden');
  });
  // Export SVG of flowchart
  // Download Flowchart as JPEG (from SVG)
  document.getElementById('btn-flow-download').addEventListener('click', async ()=>{
    if (!lastStructure.length){ el.errors.textContent='Generate a schedule first.'; return; }

    // Ensure flow DOM is measurable even when flow view is hidden
    const wasHidden = el.viewFlow.classList.contains('hidden');
    const prevInline = el.viewFlow.getAttribute('style') || '';
    if (wasHidden){
      el.viewFlow.classList.remove('hidden');
      el.viewFlow.style.position='absolute';
      el.viewFlow.style.left='-10000px';
      el.viewFlow.style.top='-10000px';
      el.viewFlow.style.visibility='hidden';
      renderFlowchart(lastStructure, lastRows, lastType);
    }

    const { svg, width, height } = buildFlowSvg();
    const serializer = new XMLSerializer();
    const svgStr = serializer.serializeToString(svg);
    const svgBlob = new Blob([svgStr], { type:'image/svg+xml;charset=utf-8' });
    const svgUrl = URL.createObjectURL(svgBlob);
    const img = new Image();
    await new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; img.src=svgUrl; });
    const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,width,height); ctx.drawImage(img,0,0);
    URL.revokeObjectURL(svgUrl);
    canvas.toBlob((blob)=>{
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='fixtureit_flowchart.jpeg'; a.click(); URL.revokeObjectURL(url);
    }, 'image/jpeg', 0.92);

    if (wasHidden){
      el.viewFlow.classList.add('hidden');
      el.viewFlow.setAttribute('style', prevInline);
    }
  });
  // removed Print button handler
  el.btnSave.addEventListener('click', ()=> saveState());
  el.btnLoad.addEventListener('click', ()=> { loadState(); updateTeamCount(); toggleSeeded(); });

  el.teams.addEventListener('input', updateTeamCount);
  el.algorithm.addEventListener('change', toggleSeeded);

  // Defaults
  loadState();
  if(!el.start.value){
    const now=new Date(); now.setMinutes(now.getMinutes()-now.getTimezoneOffset());
    el.start.value=now.toISOString().slice(0,16);
  }
  if(!el.teams.value.trim()) el.teams.value=['Team A','Team B','Team C','Team D'].join('\n');
  updateTeamCount();
  toggleSeeded();
  setView('table');

  window.addEventListener('resize', ()=>{
    if (!el.viewFlow.classList.contains('hidden') && lastStructure.length){
      renderFlowchart(lastStructure, lastRows, lastType);
    }
  });

  window.addEventListener('beforeprint', ()=>{
    PRINTING = true;
    if (!el.viewFlow.classList.contains('hidden') && lastStructure.length){
      // force reflow before measuring
      void el.flowWrap.offsetHeight;
      renderFlowchart(lastStructure, lastRows, lastType);
    }
  });

  window.addEventListener('afterprint', ()=>{
    PRINTING = false;
    if (lastStructure.length){
      renderFlowchart(lastStructure, lastRows, lastType);
    }
    document.body.classList.remove('print-mode-flow', 'print-mode-table');
  });
</script>
</body>
</html>
